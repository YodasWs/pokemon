<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Pokémon Researchers | Map Overview</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<link rel="stylesheet" href="www/css/main.css"/>
<style>
body > header > h1,
body > header > h2 {
	display: inline-block;
}
body > header > h1 + h2 {
	margin-left: 3rem;
}
#map {
	border: 1px solid black;
	min-height: 500px;
	width: 100%;
}
</style>
<script>
// For anything requiring a loaded dependency
window.onReady = function(cb){
var c=0,a=function(){if(!c){if(document.readyState=='complete'){cb();c=true}}}
if(Element.prototype.addEventListener)document.addEventListener('readystatechange',a)
else if(Element.prototype.attachEvent)document.attachEvent('onreadystatechange',a)
};
// Build Basic Game Object
window.pokemon={defaults:{}}
</script>
<script src="http://maps.google.com/maps/api/js?key=AIzaSyBeRM7BDdB6UzJ-z_IJftYP6lMx3e4u5H4&v=3&region=US&libraries=geometry"></script>
<script src="www/res/zepto.min.js"></script>
<script src="www/res/upgrdr.js"></script>
<script>
window.$ = Zepto;
pokemon.world = {
	geocoder:{},
	infoWindows:[],
	map:{},
	routes:[],
	polygons:[],
	markers:[],
	options:{},
	clusterer:{}
}
var listPolylinePoints = function() {
	var str = ''
		console.log(this)
	this.forEach(function(p,i) {
		str += '{"lat":' + p.lat() + ',"lng":' + p.lng() + '},'
	})
	console.log(str.trim(','))
	pokemon.world.drawRoutes()
};
pokemon.world.drawRoutes = function(){
	pokemon.world.polygons.forEach(function(p,i){
		p.setMap(null)
		delete pokemon.world.polygons[i]
	})
	pokemon.world.routes.forEach(function(r,i){
		r.setMap(null)
		delete pokemon.world.routes[i]
		pokemon.world.drawRoute(r)
	})
}
pokemon.world.drawRoute = function(route){
				var side1 = [],
					side2 = [],
					cir = [45,90,135],
					lastHeading = null,
					points = route.getPath ? route.getPath().getArray() : (route.points || route.getArray()),
					path = new google.maps.Polyline({
						map:pokemon.world.map,
						strokeColor:'#008800',
						strokeOpacity:0.8,
						strokeWeight:2,
						path:points,
						editable:true,
						geodesic:true
					})
				points.forEach(function(p, i){
					var pLat = typeof p.lat === 'function' ? p.lat() : p.lat,
						pLng = typeof p.lng === 'function' ? p.lng() : p.lng,
						thisPoint = new google.maps.LatLng(pLat, pLng),
						nlat, nlng,
						nextPoint,
						prevPoint,
						heading = [],
						offsetHeading,
						pgon
					// Find Headings for Offsets
					if (i < points.length - 1) {
						nLat = typeof points[i+1].lat === 'function' ? points[i+1].lat() : points[i+1].lat
						nLng = typeof points[i+1].lng === 'function' ? points[i+1].lng() : points[i+1].lng
						nextPoint = new google.maps.LatLng(nLat, nLng)
						heading.push(google.maps.geometry.spherical.computeHeading(thisPoint, nextPoint))
					}
					if (i > 0) {
						nLat = typeof points[i-1].lat === 'function' ? points[i-1].lat() : points[i-1].lat
						nLng = typeof points[i-1].lng === 'function' ? points[i-1].lng() : points[i-1].lng
						prevPoint = new google.maps.LatLng(nLat, nLng)
						heading.push(google.maps.geometry.spherical.computeHeading(thisPoint, prevPoint))
					}
					if (heading.length == 1) {
						offsetHeading = heading[0] + 90
					} else if (heading.length == 2) {
						offsetHeading = (heading[0] + heading[1]) / 2
					}
					while (offsetHeading < lastHeading - 90) offsetHeading += 180
					while (offsetHeading > lastHeading + 90) offsetHeading -= 180
					// Add Offset Points
					var radius = p.r || route.r || 100
					side1.push(google.maps.geometry.spherical.computeOffset(thisPoint, radius, offsetHeading))
					side2.unshift(google.maps.geometry.spherical.computeOffset(thisPoint, radius, offsetHeading + 180))
					if (i == 0) {
						cir = [135,90,45]
						if (heading[0] < 0 || heading[0] > 180) {
							cir.reverse()
						}
						cir.forEach(function(a){
							if (heading[0] > 180 || heading[0] < 0) a += 180
							side2.push(google.maps.geometry.spherical.computeOffset(thisPoint, radius, offsetHeading - a))
						})
					} else if (i == points.length - 1) {
						if (offsetHeading < -90) {
							cir.reverse()
						}
						cir.forEach(function(a){
							if (offsetHeading > 0) {
								a *= -1
							}
							side1.push(google.maps.geometry.spherical.computeOffset(thisPoint, radius, offsetHeading + a))
						})
					}
					lastHeading = offsetHeading
				})
				// Construct Polygon
				pgon = side1.concat(side2)
				pgon = new google.maps.Polygon({
					map:pokemon.world.map,
					strokeColor:'#008800',
					strokeOpacity:0.5,
					strokeWeight:1,
					fillColor:'#008800',
					fillOpacity:0.2,
					path:pgon
				})
				var mvc = path.getPath()
				google.maps.event.addListener(mvc, 'insert_at', listPolylinePoints)
				google.maps.event.addListener(mvc, 'remove_at', listPolylinePoints)
				google.maps.event.addListener(mvc, 'set_at', listPolylinePoints)
				pokemon.world.routes.push(path)
				pokemon.world.polygons.push(pgon)
}

$(document).on('ready', function(){
	if (!document.getElementById("map")) return false;
	pokemon.world.geocoder = new google.maps.Geocoder();
	pokemon.world.options = {
		zoom: 13,
		center: new google.maps.LatLng(35.410694, -80.84285),
		mapTypeId: google.maps.MapTypeId.ROADMAP,
		keyboardShortcuts: true,
		disableDefaultUI: true,
		mapTypeControl: false,
		scaleControl: false,
		scrollWheel: true,
		zoomControl: true,
		panControl: true,
		minZoom: 1,
		maxZoom: 16
	};
	pokemon.world.map = new google.maps.Map(document.getElementById("map"), pokemon.world.options)
	pokemon.world.bikeLayer = new google.maps.BicyclingLayer()
	pokemon.world.bikeLayer.setMap(pokemon.world.map)
	$.ajax({
		url:'www/world/us.json',
		dataType:'json',
		success:function(data){
			pokemon.json = pokemon.json||{}
			pokemon.json['us'] = data
			data.cities.forEach(function(city) {
//				console.log(city);
				new google.maps.Circle({
					strokeColor:'#888888',
					strokeOpacity:0.8,
					strokeWeight:2,
					fillColor:'#888888',
					fillOpacity:0.35,
					map:pokemon.world.map,
					center:{"lat":city.lat,"lng":city.lng},
					radius:city.r || 1000
				})
				pokemon.world.map.setCenter({"lat":city.lat,"lng":city.lng})
			})
			data.routes.forEach(pokemon.world.drawRoute)
			$(document).trigger('loaded')
		}
	})
	// Load Pokémon Spawn Data
	$(document).on('loaded', function(e){
	})
});
</script>
</head>
<body>
<header>
	<h1>Pokémon Researchers</h1>
	<h2>Map Overview</h2>
</header>
<main>
<div id="map"></div>
</main>
</body>
</html>
